#Интерактор

[Главная](../main.md)

В студийной практике используется подход проектирования приложений CleanArchitecture.
Этот подход диктует построение приложения на независимые слои. Это нужно для обеспечения 
удобного переиспользования, читабельности и легкой тестируемости кода. О том какие модули есть
в студийных проектах подробно описано [тут](arch.md).
Если интересно как работает CleanArchitecture, на хабре есть очень крутая [статья](https://habr.com/company/mobileup/blog/335382/)
Конечно там написано про андройд и mvvm. Но общий подход остается таким-же и у нас есть аналог - [MWWM](../ui/mwwm.dart)

Что такое интерактор? Это сущность, находящаяся на доменном слое приложения, которая реализует
логику некоторого бизнес процесса. Интерактор не зависит от платформы, в нем реализуется
чистая логика.

Интерактор не привязывается к какому-либо экрану. Один и тот же интерактор можно использовать в 
нескольких экранах. Например в приложении есть интерактор, который реализует логику проверки
залогинен ли пользователь или нет - AuthInteractor. Соответственно этот интерактор можно использовать как на экране
авторизации, так и на экране отображения заказов пользователя. Исходя из полученных данных от AuthInteractor
в WidgetModel произвести обработку состояний экрана и передать на презентационный слой.

Api интеракторов строится преимущнественно на Rx.
Для рассылки событий между отдельными частями приложения следует создавать Subject внутри интерактора.
У Subject схожий принцип работы с StreamController из нативного Dart, только с возможностью множественной подписки.
Более подробно об этом можно узнать в этой [статье](https://habr.com/ru/post/451292/)

### Типовые сущности, принадлежащие слою Interactor

Рассмотрим наиболее распространенные сущности, принадлежащие к этому слою.

###### 1. Репозиторий

Говоря о репозиториях, следует вспомнить паттерн, который собственно
так и называется “Репозиторий”. Суть его в том, чтобы создать некий слой
абстракции над какими-либо конкретными источниками данных, будь то например
ваша база данных или веб-сервис. Задача репозитория стать
промежуточным звеном между тем кто запрашивает данные и тем кто их отдает.
Важно понимать, что все что находится выше репозитория не должно знать о том,
как он устроен и откуда он берет эти данные. Это может быть сетевой запрос,
запрос в базу данных или же все вместе, так называемый гибридный запрос,
который подразумевает проведение конкатенации запросов на сервер и кеш по
некому установленному вами правилу.

###### 2. Storage

Обертка над источником данных. Следуя принципам SOLID, каждый класс должен иметь единственную ответственность.
Нельзя смешивать логику нескольких классов в один. Сущность Storage предназначена для абстрагирования
работы с хранилищем данных. Например есть кейс, когда необходимо сохранять данные пользователя на локальное устройство.
Это необходимо делать в различных форматах. Например xml и json. Правильным решением в этом случае будет
реализовать отдельно низкоуровневое api для работы с файловой системой устройства - FileSystem. Поверх него реализовать
две "обертки" JsonStorage и XmlStorage, которые будут использовать FileSystem для доступа к файловой системе, а логика сохранения
данных будет реализоавана непосредственно в этих классах. 

###### 3. Mapper
Объект, который переводит один тип данных в другой.

###### 4. Интерактор инициализации

Инициализация приложения чаще всего происходит на экране сплеша.
Под инициализацией понимается выполнение определенного набора правил, от
которых зависит дальнейшее поведение приложения. Например, миграции приложения
на новую версию или же получение и обновление токена, получение локации и тд.

Принято выделять данную логику в отдельный интерактор.

Интерфейс данного интерактора будет описан всего лишь одним методом - `initialize()`.

###### 5. Интерактор смены сессии пользователя

Данный интерактор инкапсулирует действия, которые необходимо выполнить при
смене сессии или пользователя. Среди таких действий могут быть - очистка
кэша, запрос на logout, кэширование токена и тд.

Реализация этого интерактора включает в себя работу с репозиторями, которые,
как мы помним, также принадлежат к этому слою. Например, UserRepository
и TokenStorage.

###### 6. Рассылка событий через Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на экране А должно вызывать обновление данных на экране Б. 
Причем, данное действие не является результатом экрана А. Тогда можно пробросить событие через общий интерактор у данных экранов.
Данный кейс, показывает, что приоритетнее использовать именно интерактор для обновления данных, а не результат выполнения экрана.
Маршрут с параметрами следует использовать там, где очевиден возврат результата, например, некая форма, которая возвращает заполненные данные на предыдущий экран.
Реализовать проброс этого события можно через создания Subject'а внутри интерактора.
При этом этот Subject должен быть приватным, а наружу должен смотреть только соответствующий Observable.

Пример: 
```dart
/// Интерактор сессии пользователя
class SessionChangedInteractor {
  final AuthInfoStorage _ts;

  final PublishSubject<SessionState> sessionSubject = PublishSubject();

  SessionChangedInteractor(this._ts);

  void onSessionChanged() {
    sessionSubject.add(SessionState.LOGGED_IN);
  }

  void forceLogout() {
    sessionSubject.add(SessionState.LOGGED_OUT);
    silentLogout();
  }

  void silentLogout() {
    _ts.clearData();
  }
}

enum SessionState { LOGGED_IN, LOGGED_OUT }
```

Далее необходимо подключить SessionChangedInteractor в WidgetModel и подписаться на изменения 
в sessionSubject:

```dart
/// Некоторая WidgetModel
class SomeWidgetModel {
   final SessionChangedInteractor _changeInteractor;
   
   SomeWidgetModel(WidgetModelDependencies baseDependencies,
        this._changeInteractor,) : super(baseDependencies);
   
    @override
     void onLoad() {
       subscribeHandleError(_changeInteractor.sessionSubject, (sessionState){
         print(sessionState.toString());});
       super.onLoad();
     }
}
```