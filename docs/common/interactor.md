#Интерактор

[Главная](../main.md)

В студийной практике используется подход проектирования приложений CleanArchitecture.
Этот подход диктует построение приложения на независимые слои. Это нужно для обеспечения 
удобного переиспользования, читабельности и легкой тестируемости кода. О том какие модули есть
в студийных проектах подробно описано [тут](arch.md).
Если интересно как работает CleanArchitecture, на хабре есть очень крутая [статья](https://habr.com/company/mobileup/blog/335382/)
Конечно там написано про андройд и mvvm. Но общий подход остается таким-же и у нас есть аналог - [MWWM](../ui/mwwm.dart)

Что такое интерактор? Это сущность, находящаяся на доменном слое приложения, которая реализует
логику некоторого бизнес процесса. Интерактор не зависит от платформы, в нем реализуется
чистая логика.

Интерактор не привязывается к какому-либо экрану. Один и тот же интерактор можно использовать в 
нескольких экранах. Например в приложении есть интерактор, который реализует логику проверки
залогинен ли пользователь или нет - AuthInteractor. Соответственно этот интерактор можно использовать как на экране
авторизации, так и на экране отображения заказов пользователя. Исходя из полученных данных от AuthInteractor
в WidgetModel произвести обработку состояний экрана и передать на презентационный слой.

Из-за того,что в интеракторах api строится на основе [rxDart](async.md), следовательно данные должны храниться
в реактивных потоках. Для хранения данных внутри интерактора используются Subjects. По сути это
те же StreamControllerы из нативного Dart, только с возможностью множественной подписки.
Более подробно об этом можно узнать в этой [статье на хабре](https://habr.com/ru/post/451292/)

### Типовые сущности, принадлежащие слою Interactor

Рассмотрим наиболее распространенные сущности, принадлежащие к этому слою.

###### 1. Репозиторий

Говоря о репозиториях, следует вспомнить паттерн, который собственно
так и называется “Репозиторий”. Суть его в том, чтобы создать некий слой
абстракции над какими-либо конкретными источниками данных, будь то например
ваша база данных или веб-сервис. Задача репозитория стать
промежуточным звеном между тем кто запрашивает данные и тем кто их отдает.
Важно понимать, что все что находится выше репозитория не должно знать о том,
как он устроен и откуда он берет эти данные. Это может быть сетевой запрос,
запрос в базу данных или же все вместе, так называемый гибридный запрос,
который подразумевает проведение конкатенации запросов на сервер и кеш по
некому установленному вами правилу.

###### 2. Storage
Обертка над источником данных

###### 3. Mapper
Обьект, который переводит один тип данных в другой

###### 4. Интерактор инициализации

Инициализация приложения чаще всего происходит на экране сплеша.
Под инициализацией понимается выполнение определенного набора правил, от
которых зависит дальнейшее поведение приложения. Например, миграции приложения
на новую версию или же получение и обновление токена, получение локации и тд.

Принято выделять данную логику в отдельный интерактор.

Интерфейс данного интерактора будет описан всего лишь одним методом - `initialize()`.

###### 5. Интерактор смены сессии пользователя

Данный интерактор инкапсулирует действия, которые необходимо выполнить при
смене сессии или пользователя. Среди таких действий могут быть - очистка
кэша, запрос на logout, кэширование токена и тд.

Реализация этого интерактора включает в себя работу с репозиторями, которые,
как мы помним, также принадлежат к этому слою. Например, UserRepository
и TokenStorage.

###### 6. Рассылка событий через Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на экране А должно вызывать обновление данных на экране Б. 
Причем, данное действие не является результатом экрана А. Тогда можно пробросить событие через общий интерактор у данных экранов.
Данный кейс, показывает, что приоритетнее использовать именно интерактор для обновления данных, а не результат выполнения экрана.
Маршрут с параметрами следует использовать там, где очевиден возврат результата, например, некая форма, которая возвращает заполненные данные на предыдущий экран.
Реализовать проброс этого события можно через создания Subject'а внутри интерактора.
При этом этот Subject должен быть приватным, а наружу должен смотреть только соответствующий Observable.

Пример: 
```dart
/// Интерактор для работы с профилем пользователя
class UserInteractor {
  final BehaviorSubject<User> _userSubject = BehaviorSubject();
  final UserRepository userRepository;

  UserInteractor(this.userRepository);

  ///Получение профиля
  Observable<User> getUser() =>
      userRepository.getUser().doOnData((u) => _userSubject.add(u));

  /// Изменение пользовательского профиля
  Observable<User> changeProfile({
    String phone,
    String email,
    String fio,
    DateTime birthDate,
    String cityName,
  }) =>
      userRepository.changeProfile(
        birthDate: birthDate,
        phone: phone,
        email: email,
        fio: fio,
        cityName: cityName,
      );
}
```

Далее подключаем UserInteractor в любую WidgetModel, где понадобиться получать текущего пользователя
и вызываем метод getUser().