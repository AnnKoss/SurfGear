[Главная](../main.md)

[TOC]

# Тестирование

## Тестирование виджетов

### Общие сведения

Файлы содержащие тесты принято распологать в подкаталоге `test` проекта.
По умолчанию исполняются тесты из всех файлов, с маской `*_test.dart` из подкаталога `test`.

Тест создается функцией `testWidgets`.
```dart
  testWidgets('Название теста', (WidgetTester tester) async {
    // Код теста
  });
```

Функции `setUp` и `tearDown` позволяют выполнить какой то код до и после каждого теста.
```dart
  setUp(() {
    // код инициализации теста
  });
  tearDown(() {
    // код финализации теста
  });
```

Класс `WidgetTester` предоставляет функции для создание тестируемого виджета и ожидания смены его состояний,
а также выполнять некоторые действия над виджетами.

* `pumpWidget` - создание тестируемого виджета
* `pump` - ожидание смены состояния тестируемого виджета в течении заданного таймаута (100 мс по умолчанию)
* `pumpAndSettle` - вызывает `pump` в цикле для смены состояний в течении заданного таймаута (100 мс по умолчанию)
* `tap` - отправить виджету нажатие
* `longPress` - длинное нажатие
* `fling` - смахивание/свайп
* `drag` - перенос
* `enterText` - ввод текста

Для того чтобы выполнить какие то действия над вложенным виджетом, то его нужно найти в дереве виджетов.
Для этого есть глобальный объект `find`, который позволяет найти виджеты в дереве по тексту(`find.text`),
по ключу (`find.byKey`), по иконке(`find.byIcon`), по типу(`find.byType`), и по другим признакам.

Моки зависимостей создаются как наследники класса `Mock` и реализуют интерфейс зависисмости.
```dart
class AuthInteractorMock extends Mock implements AuthInteractor {}
```

Для определения функциональности мока используется функция `when`, 
которая позволяет определить ответ мока на вызов той или иной функции.
```dart
when(authInteractor.checkAccess(any)).thenAnswer((_) => Future.value(true));
```

После выполнения теста можно проверить как мок был использован виджетом.
```dart
verify(appComponent.authInteractor).called(1);
verify(authInteractor.checkAccess(any)).called(1);
verifyNever(appComponent.profileInteractor);
```

### Отладка

Тесты выполняются в консоли, без какой либо графики.
Можно запускать тесты в debug режиме и ставить точки останова в коде виджета.

Для того чтобы получить представление о том, что происходит в дереве виджетов можно использовать
функцию `debugDumpApp();`, которая выводит в консоль текстовое представление иерархии всего дереве виджетов
(много текста).

Для получения представления о том как виджет использует моки используется функция `logInvocations([]);`.
Функция в качестве параметра принимает список моков, и выдает в консоль последовательность вызовов
методов у этих моков, которые совершал тестируемый виджет.

### Подготовка

Все интеракторы и прочие зависимости должны подаваться в тестируемый виджет в виде мока:
```dart
class AppComponentMock extends Mock implements AppComponent {}
class AuthInteractorMock extends Mock implements AuthInteractor {}
```

В корне дерева виджетов должен быть `Injector` и `MaterialApp`.
```dart
    await tester.pumpWidget(
      Injector<AppComponent>(
        component: appComponentMock,
        builder: (context) {
          return MaterialApp(
            home: PhoneInputScreen(),
          );
        },
      ),
    );
    await tester.pumpAndSettle();
```
В примере кода `PhoneInputScreen` - это тестируемый виджет.
Так же видно что `Injector` в качестве параметра получает мок `AppComponent`
и как обычно извлекает из него необходимые зависимости, которые нужно предварительно создать
и поместить в мок `AppComponent` с помощью `when`.

После создания тестового виджета и после любых действий с ним нужно вызывать `tester.pumpAndSettle()`
для смены состояний.

### Тестирование

Для проверки соответствия реализации виджета техническому заданию (ТЗ), которое было составлено,
мы может моделировать поведение сервисного слоя и сравнивать с тем, как реагирует на это наш виджет.

Моки могут возвращать ошибки или ошибочные данные
```dart
when(authInteractor.checkAccess(any)).thenAnswer((_) => Future.error(UnknownHttpStatusCode(null)));
```

В тесте можно и нужно нажимать куда не надо, и вводить не то что требуется,
и проверять, что это не приводит к фатальным последствиям
```dart
await tester.enterText(find.byKey(Key('phoneField')), 'bla-bla-bla');
```

После любых действий с виджетами нужно вызывать `tester.pumpAndSettle()` для смены состояний.


## Интеграционное тестирование

### Общие сведения

Файлы содержащие интеграционные тесты принято распологать в подкаталоге `test_driver` проекта.

Приложение запускается после старта специального плагина, который позволяет управлять нашим приложением.

Выглядит это следующим образом:
```dart
import 'package:flutter_driver/driver_extension.dart';
import 'package:park_flutter/main.dart' as app;
void main() {
  enableFlutterDriverExtension();
  app.main();
}
```

Запуск тестов осуществляется и коммандной строки.
Если запуск целевого приложения описан в файле `app.dart`, а тестовый сценарий называется `app_test.dart`,
то достаточно следующей комманды:
```text
$ flutter drive --target=test_driver/app.dart
```

Если тестовый сценарий имеет другое имя, тогда его нужно указать явно:
```text
flutter drive --target=test_driver/app.dart --driver=test_driver/home_test.dart
```

Из недостатков этого подхода можно отметить то, что нет возможности взаимодействовать с системными диалогами платформы.
Но например запросы привелегий можно подавлять так, как описано в [этом тикете](https://github.com/flutter/flutter/issues/12561).

Я обнаружил проблему, когда тесты завершаются и в симуляторе остается запущенное приложение,
то в нем не работает ввод в `TextFormField` виджеты.

Тест создается функцией `test`, и группируются функцией `group`.

```dart
group('park-flutter app', () {
    // драйвер, через который мы подключаемся к устройству
    FlutterDriver driver;

    // создаем подключение к драйверу
    setUpAll(() async {
      driver = await FlutterDriver.connect();
    });

    // закрываем подключение к драйверу
    tearDownAll(() async {
      if (driver != null) {
        driver.close();
      }
    });

    test('Имя теста', () async {
      // код теста
    });
    
    test('Другой тест', () async {
      // код теста
    });
}
```

### Отладка и профилирование тестов

// todo 

### Тестирование




