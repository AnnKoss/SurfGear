#Интерактор

[Главная](../main.md)

Интерактор - сущность, находящаяся на доменном слое приложения, которая реализует
логику некоторого бизнес процесса. Интерактор не зависит от платформы, в нем реализуется только логика use case, не затрагивая ui логику.
Интерактор не привязывается к какому-либо экрану. Один и тот же интерактор можно использовать в 
нескольких экранах.

Типичный пример использования:

В приложении есть экран авторизации и экран заказов.  
Необходимо проверять, залогинен ли пользователь на текущий момент.
Если да - при открытии приложения переводить на экран заказов и показывать контент, который доступен только авторизованному пользователю.
Если нет - оставаться на экране авторизации, но дать возможность просматривать заказы, которые доступны неавторизованному пользователю.

Для решения поставленой задачи следует создать интерактор, который реализует логику проверки
авторизации пользователя - AuthInteractor. В этом интеракторе происходит получение локального токена через TokenRepository.
Далее интерактор совершает запрос на сервер через AuthRepository с проверкой на валидность текущего токена и возвращает результат.
Таким образом интерактор обьединяет в себе работу нескольких репозиториев и выполняет тот use case, который нужен в каком-то конкретном месте.

Чтобы проверить, находится ли пользователь в системе на текущий момент,
AuthInteractor можно использовать как на экране авторизации, так и на экране отображения заказов. 

Интеракторы взаимодействуют с презентационным слоем только через сущность WidgetModel.

Публичные методы API интерактора строится преимущнественно на Rx.

### Типовые сущности, принадлежащие слою Interactor

Рассмотрим наиболее распространенные сущности, принадлежащие к этому слою.

###### 1. Репозиторий

Говоря о репозиториях, следует вспомнить паттерн, который собственно
так и называется “Репозиторий”. Суть его в том, чтобы создать некий слой
абстракции над какими-либо конкретными источниками данных, будь то например
ваша база данных или веб-сервис. Задача репозитория стать
промежуточным звеном между тем кто запрашивает данные и тем кто их отдает.
Важно понимать, что все что находится выше репозитория не должно знать о том,
как он устроен и откуда он берет эти данные. Это может быть сетевой запрос,
запрос в базу данных или же все вместе, так называемый гибридный запрос,
который подразумевает проведение конкатенации запросов на сервер и кеш по
некому установленному вами правилу.

###### 2. Storage

Обертка над источником данных. Следуя принципам SOLID, каждый класс должен иметь единственную ответственность.
Нельзя смешивать логику нескольких классов в один. Сущность Storage предназначена для абстрагирования
работы с хранилищем данных. Например есть кейс, когда необходимо сохранять данные пользователя на локальное устройство.
Это необходимо делать в различных форматах. Например xml и json. Правильным решением в этом случае будет
реализовать отдельно низкоуровневое api для работы с файловой системой устройства - FileSystem. Поверх него реализовать
две "обертки" JsonStorage и XmlStorage, которые будут использовать FileSystem для доступа к файловой системе, а логика сохранения
данных будет реализоавана непосредственно в этих классах. 

###### 3. Mapper
Объект, который переводит один тип данных в другой.

###### 4. Интерактор инициализации

Инициализация приложения чаще всего происходит на экране сплеша.
Под инициализацией понимается выполнение определенного набора правил, от
которых зависит дальнейшее поведение приложения. Например, миграции приложения
на новую версию или же получение и обновление токена, получение локации и тд.

Принято выделять данную логику в отдельный интерактор.

Интерфейс данного интерактора будет описан всего лишь одним методом - `initialize()`.

###### 5. Интерактор смены сессии пользователя

Данный интерактор инкапсулирует действия, которые необходимо выполнить при
смене сессии или пользователя. Среди таких действий могут быть - очистка
кэша, запрос на logout, кэширование токена и тд.

Реализация этого интерактора включает в себя работу с репозиторями, которые,
как мы помним, также принадлежат к этому слою. Например, UserRepository
и TokenStorage.

###### 6. Рассылка событий через Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на экране А должно вызывать обновление данных на экране Б. 
Причем, данное действие не является результатом экрана А. Тогда можно пробросить событие через общий интерактор у данных экранов.
Данный кейс, показывает, что приоритетнее использовать именно интерактор для обновления данных, а не результат выполнения экрана.
Маршрут с параметрами следует использовать там, где очевиден возврат результата, например, некая форма, которая возвращает заполненные данные на предыдущий экран.
Реализовать проброс этого события можно через создания Subject'а внутри интерактора.

Пример: 
```dart
/// Интерактор сессии пользователя
class SessionChangedInteractor {
  final AuthInfoStorage _ts;

  final PublishSubject<SessionState> sessionSubject = PublishSubject();

  SessionChangedInteractor(this._ts);

  void onSessionChanged() {
    sessionSubject.add(SessionState.LOGGED_IN);
  }

  void forceLogout() {
    sessionSubject.add(SessionState.LOGGED_OUT);
    silentLogout();
  }

  void silentLogout() {
    _ts.clearData();
  }
}

enum SessionState { LOGGED_IN, LOGGED_OUT }
```
Далее необходимо подключить SessionChangedInteractor в WidgetModel и подписаться на изменения 
в sessionSubject:
```dart

class FirstWidgetModel {
   final SessionChangedInteractor _changeInteractor;
   
   Action sessionChangedAction = Action();
   
   FirstWidgetModel(WidgetModelDependencies baseDependencies,
        this._changeInteractor,) : super(baseDependencies); 
   
    @override
     void onLoad() {
      bind(sessionChangedAction, (_) => _changeInteractor.onSessionChanged());
       super.onLoad();
     }
}

class SecondWidgetModel {
   final SessionChangedInteractor _changeInteractor;
   
   SecondWidgetModel(WidgetModelDependencies baseDependencies,
        this._changeInteractor,) : super(baseDependencies);
   
    @override
     void onLoad() {
       subscribeHandleError(_changeInteractor.sessionSubject, (sessionState){
         print(sessionState.toString());});
       super.onLoad();
     }
}
```